{
  "api/GRID.GridManager.html": {
    "href": "api/GRID.GridManager.html",
    "title": "Class GridManager | Tycoon Project API",
    "summary": "Class GridManager Namespace GRID Assembly Assembly-CSharp.dll Gerenciador central do sistema de grid responsável pela coordenação de todos os módulos e funcionalidades do grid. Implementa o padrão Singleton e atua como ponto de entrada para operações relacionadas ao grid. public class GridManager : MonoBehaviour Inheritance object Object Component Behaviour MonoBehaviour GridManager Remarks Este gerenciador utiliza uma arquitetura modular onde cada funcionalidade específica é delegada para módulos especializados (PathManager, HoverManager, CellValidator, etc.). Isso permite manutenção mais fácil, testabilidade melhorada e clara separação de responsabilidades. O GridManager coordena: Inicialização e configuração de todos os módulos Comunicação entre módulos através de uma API pública Gerenciamento do ciclo de vida do sistema de grid Delegação de operações específicas para módulos apropriados Properties Bounds Limites calculados do grid baseados nos tiles marcados no Tilemap. Define a área utilizável do grid para posicionamento de tiles. public BoundsInt Bounds { get; } Property Value BoundsInt BoundsCalculator Módulo responsável pelo cálculo de limites e dimensões do grid. public GridBoundsCalculator BoundsCalculator { get; } Property Value GridBoundsCalculator CellValidator Módulo responsável pela validação de células e ocupação de tiles. public CellValidator CellValidator { get; } Property Value CellValidator ClickHandler Manipulador de cliques responsável por capturar e processar input do usuário. public ClickHandler ClickHandler { get; } Property Value ClickHandler ColumnUIGenerator Módulo responsável pela geração de UI de colunas e coordenadas. public ColumnUIGenerator ColumnUIGenerator { get; } Property Value ColumnUIGenerator CoordinateConverter Módulo responsável por conversões entre diferentes sistemas de coordenadas. public CoordinateConverter CoordinateConverter { get; } Property Value CoordinateConverter CurrentHoveredCell Obtém a célula atualmente sob hover. public Vector3Int CurrentHoveredCell { get; } Property Value Vector3Int Coordenada da célula sendo destacada, ou Vector3Int.zero se nenhuma. Grid [Header(\"Core Components\")] public Grid Grid { get; } Property Value Grid HoverManager Módulo responsável pelos efeitos visuais de hover sobre tiles. public HoverManager HoverManager { get; } Property Value HoverManager Instance Instância singleton do GridManager para acesso global. public static GridManager Instance { get; } Property Value GridManager IsHovering Verifica se está fazendo hover sobre um tile. public bool IsHovering { get; } Property Value bool True se um tile está sendo destacado por hover. PathManager Módulo responsável pelo gerenciamento de caminhos e pathfinding. public PathManager PathManager { get; } Property Value PathManager TileObjects [Header(\"Debug\")] public GameObject[,] TileObjects { get; } Property Value GameObject[,] Tilemap Tilemap onde os tiles base estão posicionados e que define a área jogável. public Tilemap Tilemap { get; } Property Value Tilemap Methods AddTileToPathList(Tile) Adiciona um tile à lista de caminhos, reorganiza a lista e verifica por gaps. public void AddTileToPathList(Tile tile) Parameters tile Tile Tile a ser adicionado ao sistema de pathfinding. Remarks Delega a operação para o PathManager que gerencia a lógica de pathfinding e conectividade entre tiles de caminho. ClearHoverEffects() Remove todos os efeitos de hover. public void ClearHoverEffects() GetCellByCoordinate(Vector3Int) Retorna o GameObject da célula especificada pela coordenada lógica (coluna, linha). public GameObject GetCellByCoordinate(Vector3Int coordinate) Parameters coordinate Vector3Int Coordenada lógica [coluna, linha]. Returns GameObject GameObject na coordenada especificada, ou null se vazia. GetColumnObject(int) Retorna a coluna correspondente baseada no índice. public GameObject GetColumnObject(int col) Parameters col int Índice da coluna desejada. Returns GameObject GameObject da coluna especificada. Remarks As colunas são utilizadas para organização hierárquica dos tiles na interface. GetMouseWorldPosition() Obtém a posição do mouse convertida para o mundo. public Vector3 GetMouseWorldPosition() Returns Vector3 Posição mundial do cursor do mouse. GetTileCoordinate(Vector3Int) Converte uma posição de célula em coordenadas lógicas (coluna, linha), com origem no canto superior esquerdo. public Vector3Int GetTileCoordinate(Vector3Int cell) Parameters cell Vector3Int Célula do grid a ser convertida. Returns Vector3Int Coordenada lógica correspondente à célula. Remarks Delega para o CoordinateConverter que mantém a lógica de conversão entre sistemas. HasTileAtCell(Vector3Int) Verifica se existe um tile na célula especificada no Tilemap. public bool HasTileAtCell(Vector3Int cell) Parameters cell Vector3Int Coordenada da célula no grid a ser verificada. Returns bool True se existe um tile na célula, false caso contrário. Remarks Delega para o CellValidator que mantém a lógica de validação de células. IsCellOccupied(Vector3Int) Verifica se a célula lógica (coluna, linha) já está ocupada por um objeto. public bool IsCellOccupied(Vector3Int coordinate) Parameters coordinate Vector3Int Coordenada lógica [coluna, linha] a ser verificada. Returns bool True se a célula está ocupada, false se está livre. Remarks Utiliza o array TileObjects para verificação rápida de ocupação. SetHoverColor(Color) Define a cor do efeito de hover. public void SetHoverColor(Color color) Parameters color Color Nova cor para o efeito de hover. SetHoverEnabled(bool) Ativa ou desativa o efeito de hover. public void SetHoverEnabled(bool enabled) Parameters enabled bool True para ativar, false para desativar."
  },
  "api/GRID.MODULES.CellValidator.html": {
    "href": "api/GRID.MODULES.CellValidator.html",
    "title": "Class CellValidator | Tycoon Project API",
    "summary": "Class CellValidator Namespace GRID.MODULES Assembly Assembly-CSharp.dll public class CellValidator Inheritance object CellValidator Constructors CellValidator(Tilemap, GridManager) public CellValidator(Tilemap tilemap, GridManager gridManager) Parameters tilemap Tilemap gridManager GridManager Methods GetCellByCoordinate(Vector3Int) Retorna o GameObject da célula especificada pela coordenada lógica (coluna, linha). public GameObject GetCellByCoordinate(Vector3Int coordinate) Parameters coordinate Vector3Int Returns GameObject HasTileAtCell(Vector3Int) Verifica se existe um tile na célula especificada no Tilemap. public bool HasTileAtCell(Vector3Int cell) Parameters cell Vector3Int A posição da célula a ser verificada. Returns bool Retorna true se houver um tile na célula; caso contrário, false. IsCellOccupied(Vector3Int) Verifica se a célula lógica (coluna, linha) já está ocupada por um objeto. public bool IsCellOccupied(Vector3Int coordinate) Parameters coordinate Vector3Int Coordenada lógica da célula (coluna, linha). Returns bool Retorna true se a célula está ocupada; caso contrário, false."
  },
  "api/GRID.MODULES.ColumnUIGenerator.html": {
    "href": "api/GRID.MODULES.ColumnUIGenerator.html",
    "title": "Class ColumnUIGenerator | Tycoon Project API",
    "summary": "Class ColumnUIGenerator Namespace GRID.MODULES Assembly Assembly-CSharp.dll public class ColumnUIGenerator Inheritance object ColumnUIGenerator Constructors ColumnUIGenerator(Grid, Tilemap, TMP_FontAsset, BoundsInt) public ColumnUIGenerator(Grid grid, Tilemap tilemap, TMP_FontAsset font, BoundsInt bounds) Parameters grid Grid tilemap Tilemap font TMP_FontAsset bounds BoundsInt Methods GenerateColumnsAndCoordinates() Cria os objetos de coluna e os textos de coordenada dentro de cada coluna. public void GenerateColumnsAndCoordinates() GetColumnObject(int) Retorna a coluna correspondente baseada no índice. public GameObject GetColumnObject(int col) Parameters col int Returns GameObject"
  },
  "api/GRID.MODULES.CoordinateConverter.html": {
    "href": "api/GRID.MODULES.CoordinateConverter.html",
    "title": "Class CoordinateConverter | Tycoon Project API",
    "summary": "Class CoordinateConverter Namespace GRID.MODULES Assembly Assembly-CSharp.dll public class CoordinateConverter Inheritance object CoordinateConverter Constructors CoordinateConverter(BoundsInt) public CoordinateConverter(BoundsInt bounds) Parameters bounds BoundsInt Methods GetMouseWorldPosition() Obtém a posição do mouse convertida para o mundo. public Vector3 GetMouseWorldPosition() Returns Vector3 GetTileCoordinate(Vector3Int) Converte uma posição de célula em coordenadas lógicas (coluna, linha), com origem no canto superior esquerdo. public Vector3Int GetTileCoordinate(Vector3Int cell) Parameters cell Vector3Int Returns Vector3Int UpdateBounds(BoundsInt) Atualiza os bounds para recálculos de coordenadas. public void UpdateBounds(BoundsInt newBounds) Parameters newBounds BoundsInt"
  },
  "api/GRID.MODULES.GridBoundsCalculator.html": {
    "href": "api/GRID.MODULES.GridBoundsCalculator.html",
    "title": "Class GridBoundsCalculator | Tycoon Project API",
    "summary": "Class GridBoundsCalculator Namespace GRID.MODULES Assembly Assembly-CSharp.dll public class GridBoundsCalculator Inheritance object GridBoundsCalculator Constructors GridBoundsCalculator(Tilemap) public GridBoundsCalculator(Tilemap tilemap) Parameters tilemap Tilemap Methods GetAllMarkedTiles(BoundsInt) Conta quantas células dentro dos limites (_bounds) do Tilemap estão marcadas com tiles. public int GetAllMarkedTiles(BoundsInt bounds) Parameters bounds BoundsInt Returns int GetTrimmedBounds() Calcula os limites reais do Tilemap, baseando-se apenas nas células que possuem tiles. Ignora células vazias nas bordas que ainda estão inclusas em Tilemap.cellBounds. public BoundsInt GetTrimmedBounds() Returns BoundsInt"
  },
  "api/GRID.MODULES.HoverManager.html": {
    "href": "api/GRID.MODULES.HoverManager.html",
    "title": "Class HoverManager | Tycoon Project API",
    "summary": "Class HoverManager Namespace GRID.MODULES Assembly Assembly-CSharp.dll Módulo especializado responsável pelo sistema de hover visual sobre tiles vazios no grid. Fornece feedback visual em tempo real quando o cursor está sobre células disponíveis para posicionamento. public class HoverManager Inheritance object HoverManager Remarks Este módulo implementa um sistema eficiente de hover que: Detecta movimento do mouse sobre o grid Valida se células são elegíveis para hover (vazias mas com tiles base) Aplica efeitos visuais temporários mantendo estado original Gerencia transições suaves entre células Otimiza performance evitando atualizações desnecessárias O sistema de hover melhora significativamente a experiência do usuário ao providenciar feedback visual claro sobre onde tiles podem ser posicionados. Constructors HoverManager(GridManager, bool, Color) Inicializa o HoverManager com configurações personalizáveis. public HoverManager(GridManager gridManager, bool enableHover = true, Color hoverColor = default) Parameters gridManager GridManager Referência ao GridManager principal. enableHover bool Se os efeitos de hover devem estar habilitados inicialmente. hoverColor Color Cor para efeitos de hover (padrão é amarelo se não especificado). Remarks O construtor configura todas as dependências necessárias e define configurações padrão sensatas para o sistema de hover. A cor padrão amarela fornece bom contraste visual na maioria dos cenários. Properties CurrentHoveredCell Obtém a célula atualmente sob hover. public Vector3Int CurrentHoveredCell { get; } Property Value Vector3Int Coordenada da célula sendo destacada, ou Vector3Int.zero se nenhuma. Remarks Útil para outros sistemas que precisam coordenar com o sistema de hover, como sistemas de preview de posicionamento ou tooltips contextuais. HoverColor Obtém a cor atual do hover. public Color HoverColor { get; } Property Value Color Cor sendo usada para efeitos de hover. IsHoverEnabled Verifica se o hover está habilitado. public bool IsHoverEnabled { get; } Property Value bool True se o sistema de hover está ativo. IsHovering Verifica se está fazendo hover sobre um tile. public bool IsHovering { get; } Property Value bool True se algum tile está atualmente destacado por hover. Remarks Propriedade somente leitura que permite outros sistemas verificarem o estado do hover para coordenação de funcionalidades. Methods ClearHoverEffects() Remove todos os efeitos de hover. public void ClearHoverEffects() Remarks Método útil para limpeza quando o sistema precisa ser reiniciado ou quando o contexto muda (ex: abertura de menus). Garante que nenhum efeito visual permanente seja deixado no grid. SetHoverColor(Color) Define a cor do efeito de hover. public void SetHoverColor(Color color) Parameters color Color Nova cor para efeitos de hover. Remarks Permite personalização dinâmica da cor de hover, útil para diferentes contextos de jogo ou preferências do usuário. SetHoverEnabled(bool) Ativa ou desativa o efeito de hover. public void SetHoverEnabled(bool enabled) Parameters enabled bool True para ativar, false para desativar. Remarks Quando desabilitado, automaticamente limpa qualquer efeito de hover ativo para evitar artifacts visuais. Útil para diferentes modos de jogo onde hover pode não ser apropriado. UpdateHover() Atualiza o sistema de hover. Deve ser chamado no Update do GridManager. public void UpdateHover() Remarks Este método deve ser chamado a cada frame para manter a responsividade do sistema de hover. É otimizado para executar apenas quando necessário, verificando mudanças de estado antes de processar efeitos visuais."
  },
  "api/GRID.MODULES.PathManager.html": {
    "href": "api/GRID.MODULES.PathManager.html",
    "title": "Class PathManager | Tycoon Project API",
    "summary": "Class PathManager Namespace GRID.MODULES Assembly Assembly-CSharp.dll public class PathManager Inheritance object PathManager Constructors PathManager(GridManager) Inicializa o PathManager com uma referência ao GridManager. public PathManager(GridManager gridManager) Parameters gridManager GridManager Methods AddTileToPathList(Tile) Adiciona um tile à lista de caminhos, reorganiza a lista e verifica por gaps. public void AddTileToPathList(Tile tile) Parameters tile Tile ClearPath() Remove todos os tiles da lista de caminhos. public void ClearPath() GetPathTiles() Retorna uma cópia da lista de tiles do caminho. public List<Tile> GetPathTiles() Returns List<Tile>"
  },
  "api/GRID.MODULES.html": {
    "href": "api/GRID.MODULES.html",
    "title": "Namespace GRID.MODULES | Tycoon Project API",
    "summary": "Namespace GRID.MODULES Classes CellValidator ColumnUIGenerator CoordinateConverter GridBoundsCalculator HoverManager Módulo especializado responsável pelo sistema de hover visual sobre tiles vazios no grid. Fornece feedback visual em tempo real quando o cursor está sobre células disponíveis para posicionamento. PathManager"
  },
  "api/GRID.TILE.Tile.html": {
    "href": "api/GRID.TILE.Tile.html",
    "title": "Class Tile | Tycoon Project API",
    "summary": "Class Tile Namespace GRID.TILE Assembly Assembly-CSharp.dll Componente responsável pelo comportamento individual de cada tile no sistema de grid. Gerencia posicionamento, estado visual, interação com mouse e integração com o sistema de grade. public class Tile : MonoBehaviour Inheritance object Object Component Behaviour MonoBehaviour Tile Remarks Esta classe representa um tile individual que pode ser posicionado na grade do jogo. Implementa funcionalidades como modo fantasma (ghost mode), validação de posicionamento, seguimento do mouse e transições de estado. Integra-se com o GridManager para coordenação global e com o sistema de input para responder a cliques do usuário. Properties CurrentState Estado atual do tile no ciclo de vida do posicionamento. public TileState CurrentState { get; } Property Value TileState Valor padrão é Unplaced. TileItemData Dados configuráveis do tile contendo informações visuais e funcionais. public TileItemData TileItemData { get; } Property Value TileItemData Null por padrão, deve ser configurado durante a instanciação. Methods HandleSelection(bool) Ativa ou desativa o modo fantasma (ghost mode) do tile, alterando sua opacidade. public void HandleSelection(bool isGhostModeActive) Parameters isGhostModeActive bool True para ativar o modo fantasma, false para desativar. Remarks O modo fantasma faz o tile seguir o cursor do mouse com opacidade reduzida, indicando visualmente que está sendo posicionado. Quando desativado, a opacidade é restaurada automaticamente. ResetOpacity() Restaura a opacidade total do tile. public void ResetOpacity() Remarks Chamado quando o tile sai do modo fantasma ou é definitivamente posicionado, restaurando a visibilidade completa do tile. SetTileItemData(TileItemData) Define os dados do tile e atualiza sua cor visual. public void SetTileItemData(TileItemData newItemData) Parameters newItemData TileItemData Novos dados do tile contendo informações visuais e funcionais. Remarks Este método deve ser chamado durante a inicialização do tile para configurar suas propriedades visuais e comportamentais baseadas no TileItemData."
  },
  "api/GRID.TILE.TileItemData.html": {
    "href": "api/GRID.TILE.TileItemData.html",
    "title": "Class TileItemData | Tycoon Project API",
    "summary": "Class TileItemData Namespace GRID.TILE Assembly Assembly-CSharp.dll ScriptableObject responsável por armazenar dados configuráveis de tiles para o sistema de grid. Permite criação de diferentes tipos de tiles através do Unity Editor com propriedades visuais e funcionais. [CreateAssetMenu(fileName = \"TileItemData\", menuName = \"Tiles/TileItemData\", order = 1)] public class TileItemData : ScriptableObject Inheritance object Object ScriptableObject TileItemData Remarks Este ScriptableObject facilita a criação e configuração de tiles de forma modular e reutilizável. Cada tile pode ter suas próprias propriedades visuais (sprite, cor) e funcionais (tipo, nome). A configuração via Inspector permite designers criarem novos tipos de tiles sem programação. Properties Color Cor visual aplicada ao tile para diferenciação visual no grid. public Color Color { get; } Property Value Color Cor branca por padrão. Coordinate Coordenada atual do tile no sistema de grid 2D. public Vector2 Coordinate { get; } Property Value Vector2 Vector2.zero por padrão (posição 0,0). Name Nome identificador do tile exibido na interface do usuário. public string Name { get; } Property Value string String vazia por padrão. Sprite Sprite visual do tile renderizado no grid. public Sprite Sprite { get; } Property Value Sprite Null por padrão, deve ser configurado no Inspector. TileType Tipo funcional do tile que determina seu comportamento no grid. public TileType TileType { get; } Property Value TileType Valor padrão é Default. Methods SetColor(Color) Define a cor visual do tile. public void SetColor(Color color) Parameters color Color Nova cor a ser aplicada ao tile. SetCoordinate(int, int) Define a coordenada do tile no grid usando valores inteiros. public void SetCoordinate(int column, int row) Parameters column int Coordenada X (coluna) no grid. row int Coordenada Y (linha) no grid. SetName(string) Define o nome identificador do tile. public void SetName(string name) Parameters name string Novo nome para o tile. SetTileType(TileType) Define o tipo funcional do tile. public void SetTileType(TileType tileType) Parameters tileType TileType Novo tipo que determina o comportamento do tile."
  },
  "api/GRID.TILE.TilePool.html": {
    "href": "api/GRID.TILE.TilePool.html",
    "title": "Class TilePool | Tycoon Project API",
    "summary": "Class TilePool Namespace GRID.TILE Assembly Assembly-CSharp.dll Gerencia um pool de tiles para otimizar a criação e reutilização de GameObjects. Implementa o padrão Object Pool para evitar instanciamentos e destruições frequentes. public class TilePool : MonoBehaviour Inheritance object Object Component Behaviour MonoBehaviour TilePool Remarks O sistema de pooling: Pré-instancia uma quantidade definida de tiles Reutiliza objetos inativos em vez de criar novos Organiza tiles em grupos de 10 para melhor hierarquia Melhora significativamente a performance do jogo Reduz o garbage collection Fields amountToPool Quantidade total de tiles para pré-instanciar na pool. [Tooltip(\"Número de tiles a serem criados na inicialização\")] public int amountToPool Field Value int objectToPool Prefab do tile que será usado para criar os objetos da pool. [Tooltip(\"Prefab do tile a ser instanciado na pool\")] public GameObject objectToPool Field Value GameObject pooledObjects Lista de todos os tiles disponíveis na pool. [HideInInspector] public List<GameObject> pooledObjects Field Value List<GameObject> pooledObjectsContainer Container onde os objetos da pool serão organizados na hierarquia. [Tooltip(\"GameObject pai que conterá todos os tiles da pool\")] public GameObject pooledObjectsContainer Field Value GameObject Properties Instance Instância singleton do TilePool. public static TilePool Instance { get; } Property Value TilePool Methods GetPooledObject() Obtém um tile inativo da pool para reutilização. public GameObject GetPooledObject() Returns GameObject Um GameObject inativo da pool, ou null se nenhum estiver disponível. O tile retornado deve ser ativado pelo chamador antes do uso. Remarks Este método implementa o padrão Object Pool para otimização de performance, evitando a criação e destruição constante de GameObjects durante o runtime. Itera através da pool procurando por objetos inativos disponíveis para reutilização."
  },
  "api/GRID.TILE.TileState.html": {
    "href": "api/GRID.TILE.TileState.html",
    "title": "Enum TileState | Tycoon Project API",
    "summary": "Enum TileState Namespace GRID.TILE Assembly Assembly-CSharp.dll Define os estados possíveis de um tile durante seu ciclo de vida. public enum TileState Fields Placed = 1 Estado final quando o tile foi posicionado com sucesso no grid. Neste estado o tile não pode mais ser movido e tem opacidade total. Unplaced = 0 Estado inicial quando o tile não foi posicionado no grid. Neste estado o tile segue o cursor em modo fantasma. Remarks O sistema de estados controla: Comportamento visual (ghost mode, opacidade) Interações permitidas (movimento, posicionamento) Validações de posicionamento Transições entre estados"
  },
  "api/GRID.TILE.TileType.html": {
    "href": "api/GRID.TILE.TileType.html",
    "title": "Enum TileType | Tycoon Project API",
    "summary": "Enum TileType Namespace GRID.TILE Assembly Assembly-CSharp.dll Define os diferentes tipos de tiles disponíveis no sistema de grid. public enum TileType Fields Building = 1 Tile usado para construções e estruturas do jogo. Default = 0 Tipo padrão de tile sem funcionalidades especiais. Path = 2 Tile usado para criar caminhos e conectar diferentes áreas. Participa do sistema de pathfinding automático. Remarks Cada tipo de tile tem comportamentos específicos: Default: Tile básico sem funcionalidades especiais Building: Tiles para construções e estruturas Path: Tiles que formam caminhos e conectam outras estruturas"
  },
  "api/GRID.TILE.html": {
    "href": "api/GRID.TILE.html",
    "title": "Namespace GRID.TILE | Tycoon Project API",
    "summary": "Namespace GRID.TILE Classes Tile Componente responsável pelo comportamento individual de cada tile no sistema de grid. Gerencia posicionamento, estado visual, interação com mouse e integração com o sistema de grade. TileItemData ScriptableObject responsável por armazenar dados configuráveis de tiles para o sistema de grid. Permite criação de diferentes tipos de tiles através do Unity Editor com propriedades visuais e funcionais. TilePool Gerencia um pool de tiles para otimizar a criação e reutilização de GameObjects. Implementa o padrão Object Pool para evitar instanciamentos e destruições frequentes. Enums TileState Define os estados possíveis de um tile durante seu ciclo de vida. TileType Define os diferentes tipos de tiles disponíveis no sistema de grid."
  },
  "api/GRID.html": {
    "href": "api/GRID.html",
    "title": "Namespace GRID | Tycoon Project API",
    "summary": "Namespace GRID Classes GridManager Gerenciador central do sistema de grid responsável pela coordenação de todos os módulos e funcionalidades do grid. Implementa o padrão Singleton e atua como ponto de entrada para operações relacionadas ao grid."
  },
  "api/SHOP.ShopManager.html": {
    "href": "api/SHOP.ShopManager.html",
    "title": "Class ShopManager | Tycoon Project API",
    "summary": "Class ShopManager Namespace SHOP Assembly Assembly-CSharp.dll Gerenciador principal do sistema de loja responsável pela interface, animações e seleção de tiles. Controla a abertura/fechamento da loja, configuração de tiles disponíveis e instanciação de tiles selecionados. public class ShopManager : MonoBehaviour Inheritance object Object Component Behaviour MonoBehaviour ShopManager Remarks Este gerenciador implementa um sistema completo de loja para o jogo de tycoon, permitindo que jogadores selecionem diferentes tipos de tiles para posicionamento no grid. Inclui animações suaves de abertura/fechamento, configuração dinâmica de tiles e integração com o sistema de Object Pool para otimização de performance."
  },
  "api/SHOP.html": {
    "href": "api/SHOP.html",
    "title": "Namespace SHOP | Tycoon Project API",
    "summary": "Namespace SHOP Classes ShopManager Gerenciador principal do sistema de loja responsável pela interface, animações e seleção de tiles. Controla a abertura/fechamento da loja, configuração de tiles disponíveis e instanciação de tiles selecionados."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Tycoon Project - API Reference | Tycoon Project API",
    "summary": "Tycoon Project - API Reference Bem-vindo à documentação da API do Tycoon Project, um sistema modular de grid desenvolvido em Unity para jogos do gênero tycoon. \uD83D\uDCCB Visão Geral Este projeto implementa um sistema robusto e modular de grid com funcionalidades avançadas para posicionamento de tiles, efeitos visuais, gerenciamento de pathfinding e interface de loja. A arquitetura modular garante escalabilidade, manutenibilidade e performance otimizada. \uD83C\uDFD7️ Arquitetura do Sistema Componentes Principais Namespace Descrição Responsabilidades GRID Sistema central de grid Coordenação de módulos, gerenciamento de estado global GRID.MODULES Módulos especializados Hover, pathfinding, validação, conversão de coordenadas GRID.TILE Sistema de tiles Comportamento, dados e pooling de tiles SHOP Sistema de loja Interface, seleção e instanciação de tiles \uD83C\uDFAF Funcionalidades Principais Sistema de Grid Modular GridManager - Gerenciador central com padrão Singleton Arquitetura modular - Separação clara de responsabilidades Sistema de coordenadas - Conversão automática entre sistemas de coordenadas Validação de células - Verificação de ocupação e disponibilidade Efeitos Visuais Avançados HoverManager - Sistema de hover responsivo Feedback visual em tempo real - Destaque de células disponíveis Otimização de performance - Atualizações apenas quando necessário Gerenciamento de estado - Preservação e restauração de cores originais Sistema de Tiles Inteligente Tile - Comportamento individual com ghost mode TilePool - Object Pool para otimização de performance TileItemData - ScriptableObject configurável Estados bem definidos - Transições controladas entre TileState Interface de Loja Intuitiva ShopManager - Gerenciamento completo da loja Animações suaves - Transições coordenadas com corrotinas Seleção de tiles - Interface responsiva com preview visual Integração com pool - Reutilização eficiente de objetos \uD83D\uDE80 Começando Componentes Essenciais Configurar GridManager // O GridManager inicializa automaticamente todos os módulos GridManager.Instance.SetHoverEnabled(true); GridManager.Instance.SetHoverColor(Color.yellow); Usar Sistema de Tiles // Obter tile da pool GameObject tileObject = TilePool.Instance.GetPooledObject(); Tile tile = tileObject.GetComponent<Tile>(); // Configurar dados do tile tile.SetTileItemData(tileItemData); tile.HandleSelection(true); // Ativar ghost mode Gerenciar Loja // A loja é controlada automaticamente via ShopManager // Pressione Tab para abrir/fechar \uD83D\uDCD0 Sistema de Coordenadas O projeto utiliza um sistema duplo de coordenadas: Coordenadas de Célula: Posição física no Grid do Unity Coordenadas Lógicas: Sistema lógico [coluna, linha] para organização A conversão é realizada automaticamente pelo CoordinateConverter. \uD83C\uDFAE Input e Interação Controles Principais Clique do Mouse: Posicionar tiles selecionados Tab: Abrir/fechar loja Hover: Feedback visual automático Sistema de Input O ClickHandler utiliza o Unity Input System para capturar eventos de forma eficiente e responsiva. \uD83D\uDD27 Módulos Especializados Validação e Conversão CellValidator - Validação de células e ocupação CoordinateConverter - Conversão entre sistemas de coordenadas Interface e Organização ColumnUIGenerator - Geração de UI para colunas GridBoundsCalculator - Cálculo de limites do grid Pathfinding PathManager - Gerenciamento de caminhos e conectividade \uD83C\uDFC6 Padrões de Design Implementados Singleton: GridManager, TilePool Object Pool: Sistema de tiles para performance Module Pattern: Separação de responsabilidades Observer Pattern: Sistema de eventos para input State Pattern: Estados de tiles bem definidos \uD83D\uDCDA Tipos e Enumerações TileType Default: Tile padrão genérico Building: Construções e estruturas Path: Caminhos para pathfinding TileState Unplaced: Tile não posicionado (ghost mode) Placed: Tile posicionado no grid \uD83C\uDFA8 Características Visuais Ghost Mode: Preview transparente durante posicionamento Hover Effects: Destaque de células disponíveis Animações Suaves: Transições controladas por Animator Organização Hierárquica: Tiles organizados por colunas \uD83D\uDD0D Navegação da API Explore a documentação através dos namespaces organizados: \uD83C\uDFE0 GRID - Sistema central ⚙️ GRID.MODULES - Módulos especializados \uD83C\uDFAF GRID.TILE - Sistema de tiles \uD83D\uDED2 SHOP - Sistema de loja Desenvolvido por: Murillo Gomes Yonamine Versão: Unity 2022.3 LTS Padrão de Documentação: DocFX com XML Documentation"
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started - Guia Prático | Tycoon Project API",
    "summary": "Getting Started - Guia Prático Este guia irá levá-lo desde a configuração inicial até a criação de seu primeiro jogo usando o Tycoon Project. Em poucos minutos você terá um sistema de grid funcional com todas as funcionalidades principais. \uD83D\uDCCB Pré-requisitos Antes de começar, certifique-se de ter: Unity 2022.3 LTS ou superior Visual Studio ou VS Code para edição de código Conhecimento básico de C# e Unity Git (opcional, para versionamento) \uD83D\uDE80 Configuração Rápida Passo 1: Setup do Projeto Clone ou baixe o projeto git clone https://github.com/MurilloYonamine/Tycoon-Project.git Abra no Unity Abra o Unity Hub Clique em \"Open\" e selecione a pasta do projeto Aguarde o Unity importar os assets Verifique as dependências Unity Input System deve estar instalado TextMeshPro deve estar configurado Passo 2: Configuração da Cena Abra a cena principal Assets/Scenes/MainScene.unity Verifique os componentes essenciais GridManager deve estar presente na cena Tilemap e Grid devem estar configurados TilePool deve estar vinculado Configure o Input System // O ClickHandler já está configurado para capturar: // - Cliques do mouse (posicionamento) // - Tecla Tab (abrir/fechar loja) \uD83C\uDFAF Primeiro Teste Execute o Projeto Pressione Play no Unity Pressione Tab para abrir a loja Clique em um tile na loja para selecioná-lo Mova o mouse sobre o grid (observe o hover effect) Clique no grid para posicionar o tile \uD83C\uDF89 Parabéns! Seu sistema básico está funcionando! \uD83D\uDD27 Configuração Básica Configurando o GridManager O GridManager é o coração do sistema. Aqui está como configurá-lo: public class MyGameManager : MonoBehaviour { void Start() { // Configurar hover effects GridManager.Instance.SetHoverEnabled(true); GridManager.Instance.SetHoverColor(Color.yellow); // Verificar se o sistema está inicializado if (GridManager.Instance != null) { Debug.Log(\"Grid System inicializado com sucesso!\"); } } } Configurando a Loja A ShopManager controla a interface de seleção: public class CustomShopSetup : MonoBehaviour { void Start() { // A loja é configurada automaticamente // Controles: // - Tab: Abrir/Fechar // - Clique: Selecionar tile // Para customizar tiles programaticamente: CreateCustomTile(); } void CreateCustomTile() { // Criar dados customizados para tile TileItemData customTile = ScriptableObject.CreateInstance<TileItemData>(); customTile.SetName(\"Meu Tile Customizado\"); customTile.SetColor(Color.blue); customTile.SetTileType(TileType.Building); } } Configurando Object Pool O TilePool otimiza performance: void ConfigureTilePool() { // O pool é configurado automaticamente baseado no tamanho do grid // Mas você pode ajustar manualmente: TilePool.Instance.amountToPool = 200; // Aumentar para grids maiores // Verificar tiles disponíveis GameObject availableTile = TilePool.Instance.GetPooledObject(); if (availableTile != null) { Debug.Log(\"Tile disponível no pool!\"); } } \uD83C\uDFAE Exemplos Práticos Exemplo 1: Jogo de Construção de Cidade public class CityBuilder : MonoBehaviour { [SerializeField] private TileItemData houseTile; [SerializeField] private TileItemData roadTile; [SerializeField] private TileItemData parkTile; void Start() { SetupCityTiles(); } void SetupCityTiles() { // Configurar tile de casa houseTile.SetName(\"Casa\"); houseTile.SetColor(Color.blue); houseTile.SetTileType(TileType.Building); // Configurar tile de estrada roadTile.SetName(\"Estrada\"); roadTile.SetColor(Color.gray); roadTile.SetTileType(TileType.Path); // Configurar tile de parque parkTile.SetName(\"Parque\"); parkTile.SetColor(Color.green); parkTile.SetTileType(TileType.Building); } void Update() { // Teclas de atalho para seleção rápida if (Input.GetKeyDown(KeyCode.H)) SelectTile(houseTile); if (Input.GetKeyDown(KeyCode.R)) SelectTile(roadTile); if (Input.GetKeyDown(KeyCode.P)) SelectTile(parkTile); } void SelectTile(TileItemData tileData) { GameObject newTile = TilePool.Instance.GetPooledObject(); if (newTile != null) { newTile.SetActive(true); Tile tileComponent = newTile.GetComponent<Tile>(); tileComponent.SetTileItemData(tileData); tileComponent.HandleSelection(true); // Ativar ghost mode } } } Exemplo 2: Sistema de Fazenda public class FarmSystem : MonoBehaviour { [Header(\"Farm Tiles\")] public TileItemData wheatTile; public TileItemData cornTile; public TileItemData waterTile; void Start() { ConfigureFarmTiles(); SetupFarmControls(); } void ConfigureFarmTiles() { // Trigo wheatTile.SetName(\"Trigo\"); wheatTile.SetColor(Color.yellow); wheatTile.SetTileType(TileType.Building); // Milho cornTile.SetName(\"Milho\"); cornTile.SetColor(new Color(1f, 0.8f, 0f)); // Dourado cornTile.SetTileType(TileType.Building); // Irrigação waterTile.SetName(\"Irrigação\"); waterTile.SetColor(Color.cyan); waterTile.SetTileType(TileType.Path); } void SetupFarmControls() { // Configurar hover especial para fazenda GridManager.Instance.SetHoverColor(Color.green); // Sistema automático de irrigação StartCoroutine(AutoIrrigationSystem()); } IEnumerator AutoIrrigationSystem() { while (true) { yield return new WaitForSeconds(5f); // Verificar tiles que precisam de água CheckIrrigationNeeds(); } } void CheckIrrigationNeeds() { // Lógica para verificar tiles de plantio próximos à água Debug.Log(\"Verificando necessidades de irrigação...\"); } } Exemplo 3: Sistema de Defesa Tower Defense public class TowerDefense : MonoBehaviour { [Header(\"Defense Tiles\")] public TileItemData towerTile; public TileItemData wallTile; public TileItemData pathTile; void Start() { SetupDefenseTiles(); ConfigureTowerDefenseGrid(); } void SetupDefenseTiles() { // Torre de defesa towerTile.SetName(\"Torre\"); towerTile.SetColor(Color.red); towerTile.SetTileType(TileType.Building); // Muralha wallTile.SetName(\"Muralha\"); wallTile.SetColor(Color.gray); wallTile.SetTileType(TileType.Building); // Caminho dos inimigos pathTile.SetName(\"Caminho\"); pathTile.SetColor(Color.brown); pathTile.SetTileType(TileType.Path); } void ConfigureTowerDefenseGrid() { // Hover especial para áreas de construção GridManager.Instance.SetHoverColor(Color.red); // Detectar quando uma torre é posicionada // (Integrar com sistema de eventos) } void OnTowerPlaced(Vector3Int position) { Debug.Log($\"Torre posicionada em: {position}\"); // Lógica de range de ataque ShowTowerRange(position); } void ShowTowerRange(Vector3Int towerPosition) { // Destacar células dentro do alcance da torre int range = 3; for (int x = -range; x <= range; x++) { for (int y = -range; y <= range; y++) { Vector3Int checkPosition = towerPosition + new Vector3Int(x, y, 0); // Destacar posição se estiver no alcance } } } } ⚙️ Customização Avançada Criando Novos Tipos de Tile // 1. Estenda o enum TileType public enum TileType { Default, Building, Path, Water, // Novo tipo Forest, // Novo tipo Mountain // Novo tipo } // 2. Crie comportamentos customizados public class WaterTile : MonoBehaviour { void Start() { // Comportamento específico para tiles de água AddRippleEffect(); } void AddRippleEffect() { // Adicionar efeito visual de ondulação } } Customizando Efeitos Visuais public class CustomVisualEffects : MonoBehaviour { void Start() { CustomizeHoverEffects(); AddParticleEffects(); } void CustomizeHoverEffects() { // Hover customizado com gradiente Color[] hoverGradient = { Color.yellow, Color.orange, Color.red }; // Aplicar baseado no tipo de tile GridManager.Instance.SetHoverColor(hoverGradient[0]); } void AddParticleEffects() { // Adicionar partículas quando tiles são posicionados // Integrar com sistema de eventos do GridManager } } Sistema de Save/Load [System.Serializable] public class GridSaveData { public List<TileSaveData> placedTiles = new List<TileSaveData>(); } [System.Serializable] public class TileSaveData { public Vector3Int position; public TileType tileType; public string tileName; public Color tileColor; } public class SaveSystem : MonoBehaviour { public void SaveGrid() { GridSaveData saveData = new GridSaveData(); // Coletar todos os tiles posicionados for (int x = 0; x < GridManager.Instance.Bounds.size.x; x++) { for (int y = 0; y < GridManager.Instance.Bounds.size.y; y++) { GameObject tileObject = GridManager.Instance.TileObjects[x, y]; if (tileObject != null) { Tile tile = tileObject.GetComponent<Tile>(); TileSaveData tileData = new TileSaveData { position = new Vector3Int(x, y, 0), tileType = tile.TileItemData.TileType, tileName = tile.TileItemData.Name, tileColor = tile.TileItemData.Color }; saveData.placedTiles.Add(tileData); } } } // Salvar em JSON string json = JsonUtility.ToJson(saveData, true); System.IO.File.WriteAllText(Application.persistentDataPath + \"/grid_save.json\", json); Debug.Log(\"Grid salvo com sucesso!\"); } public void LoadGrid() { string filePath = Application.persistentDataPath + \"/grid_save.json\"; if (System.IO.File.Exists(filePath)) { string json = System.IO.File.ReadAllText(filePath); GridSaveData saveData = JsonUtility.FromJson<GridSaveData>(json); // Limpar grid atual ClearGrid(); // Recriar tiles salvos foreach (TileSaveData tileData in saveData.placedTiles) { RecreateFile(tileData); } Debug.Log(\"Grid carregado com sucesso!\"); } } void ClearGrid() { // Retornar todos os tiles para o pool for (int x = 0; x < GridManager.Instance.Bounds.size.x; x++) { for (int y = 0; y < GridManager.Instance.Bounds.size.y; y++) { GameObject tileObject = GridManager.Instance.TileObjects[x, y]; if (tileObject != null) { TilePool.Instance.ReturnPooledObject(tileObject); GridManager.Instance.TileObjects[x, y] = null; } } } } void RecreateFile(TileSaveData tileData) { // Obter tile do pool GameObject newTile = TilePool.Instance.GetPooledObject(); if (newTile != null) { // Configurar tile Tile tileComponent = newTile.GetComponent<Tile>(); TileItemData itemData = ScriptableObject.CreateInstance<TileItemData>(); itemData.SetName(tileData.tileName); itemData.SetColor(tileData.tileColor); itemData.SetTileType(tileData.tileType); itemData.SetCoordinate(tileData.position.x, tileData.position.y); tileComponent.SetTileItemData(itemData); // Posicionar no grid Vector3 worldPosition = GridManager.Instance.Grid.GetCellCenterWorld(tileData.position); newTile.transform.position = worldPosition; newTile.SetActive(true); // Registrar no GridManager GridManager.Instance.TileObjects[tileData.position.x, tileData.position.y] = newTile; } } } \uD83D\uDC1B Troubleshooting Problemas Comuns 1. Tiles não aparecem no hover // Verificar se o Tilemap tem tiles marcados Debug.Log($\"Tiles no Tilemap: {GridManager.Instance.BoundsCalculator.GetAllMarkedTiles(GridManager.Instance.Bounds)}\"); // Verificar se hover está habilitado Debug.Log($\"Hover habilitado: {GridManager.Instance.IsHovering}\"); 2. Pool de tiles vazio // Verificar configuração do pool Debug.Log($\"Tiles no pool: {TilePool.Instance.amountToPool}\"); // Reconfigurar se necessário TilePool.Instance.amountToPool = 100; 3. Cliques não funcionam // Verificar se ClickHandler está ativo Debug.Log($\"ClickHandler ativo: {GridManager.Instance.ClickHandler != null}\"); // Verificar se Input System está configurado // Window > Analysis > Input Debugger Dicas de Performance Otimização para Grids Grandes void OptimizeForLargeGrids() { // Aumentar pool baseado no tamanho do grid int gridSize = GridManager.Instance.Bounds.size.x * GridManager.Instance.Bounds.size.y; TilePool.Instance.amountToPool = Mathf.Min(gridSize / 4, 500); // Máximo 500 tiles // Desabilitar hover se performance for crítica if (gridSize > 10000) { GridManager.Instance.SetHoverEnabled(false); } } Otimização de Renderização void OptimizeRendering() { // Usar LOD para tiles distantes // Implementar frustum culling // Agrupar tiles similares em batches } \uD83D\uDCDA Próximos Passos Aprofunde seus Conhecimentos API Reference Completa - Explore todas as funcionalidades Módulos Avançados - PathManager, HoverManager, etc. Casos de Uso Específicos - Exemplos por gênero de jogo Expanda o Sistema Adicione novos tipos de tile - Customize para seu jogo Implemente save/load - Persistência de dados Crie efeitos visuais - Partículas e animações Integre com outros sistemas - Audio, UI, Networking \uD83D\uDCA1 Dicas Finais Melhores Práticas Use Object Pooling sempre que possível Mantenha módulos independentes para facilitar testes Documente suas customizações para facilitar manutenção Teste em diferentes tamanhos de grid para garantir performance Recursos Adicionais Documentação Unity - Referência oficial Input System Guide - Sistema de input moderno Performance Optimization - Guias de otimização Unity 6 | Sistema Modular | Performance Otimizada"
  },
  "docs/introduction.html": {
    "href": "docs/introduction.html",
    "title": "Introdução ao Tycoon Project | Tycoon Project API",
    "summary": "Introdução ao Tycoon Project Bem-vindo ao Tycoon Project, um sistema modular e robusto de grid desenvolvido em Unity para criação de jogos do gênero tycoon. Este projeto implementa uma arquitetura escalável que facilita o desenvolvimento de jogos de construção e gerenciamento. \uD83C\uDFAF O que é o Tycoon Project? O Tycoon Project é uma solução completa que fornece: Sistema de Grid Inteligente - Gerenciamento avançado de posicionamento de objetos Arquitetura Modular - Componentes independentes e reutilizáveis Performance Otimizada - Object pooling e otimizações de rendering Interface Intuitiva - Sistema de loja e seleção responsivo Efeitos Visuais - Hover effects e feedback visual em tempo real \uD83C\uDFD7️ Arquitetura do Sistema Princípios Fundamentais O projeto foi construído seguindo princípios sólidos de engenharia de software: 1. Separação de Responsabilidades Cada módulo tem uma responsabilidade específica e bem definida: GridManager - Coordenação central e orquestração HoverManager - Efeitos visuais de hover PathManager - Sistema de pathfinding TilePool - Gerenciamento de performance via object pooling ShopManager - Interface de seleção e compra 2. Modularidade // Cada módulo é independente e pode ser usado separadamente HoverManager hoverModule = new HoverManager(gridManager, true, Color.yellow); PathManager pathModule = new PathManager(gridManager); 3. Performance First // Object pooling para reutilização eficiente GameObject tile = TilePool.Instance.GetPooledObject(); // Atualizações otimizadas apenas quando necessário if (currentCell != previousCell) ProcessHover(); \uD83C\uDFAE Funcionalidades Principais Sistema de Grid Avançado O coração do sistema é o GridManager, que coordena todas as operações: // Inicialização automática de todos os módulos GridManager.Instance.InitializeModules(); // API unificada para operações de grid bool isOccupied = GridManager.Instance.IsCellOccupied(coordinate); Vector3Int logicalCoord = GridManager.Instance.GetTileCoordinate(cellPosition); Efeitos Visuais Responsivos O HoverManager fornece feedback visual imediato: // Configuração simples de hover GridManager.Instance.SetHoverEnabled(true); GridManager.Instance.SetHoverColor(Color.yellow); // Sistema automático de detecção // Destaca células livres quando o mouse passa sobre elas Sistema de Tiles Inteligente Cada tile possui comportamento rico e estados bem definidos: // Estados do ciclo de vida public enum TileState { Unplaced, // Modo fantasma durante posicionamento Placed // Definitivamente posicionado no grid } // Comportamento de ghost mode tile.HandleSelection(true); // Ativa preview transparente tile.FollowMouse(); // Segue cursor do mouse Object Pool para Performance O TilePool otimiza performance reutilizando objetos: // Singleton pattern para acesso global TilePool.Instance.amountToPool = 100; // Reutilização eficiente GameObject reusedTile = TilePool.Instance.GetPooledObject(); TilePool.Instance.ReturnPooledObject(tileToReturn); \uD83D\uDEE0️ Tecnologias e Padrões Tecnologias Utilizadas Unity 2022.3 LTS - Engine principal C# 9.0 - Linguagem de programação Unity Input System - Sistema moderno de input ScriptableObjects - Configuração flexível de dados Tilemap System - Renderização eficiente de tiles Padrões de Design Implementados Singleton Pattern public class GridManager : MonoBehaviour { public static GridManager Instance { get; private set; } private void Awake() { if (Instance != null && Instance != this) { Destroy(this); return; } Instance = this; } } Object Pool Pattern public class TilePool : MonoBehaviour { private List<GameObject> pooledObjects; public GameObject GetPooledObject() { for (int i = 0; i < pooledObjects.Count; i++) { if (!pooledObjects[i].activeInHierarchy) return pooledObjects[i]; } return null; } } Module Pattern // Cada funcionalidade como módulo independente public class HoverManager { /* Lógica de hover */ } public class PathManager { /* Lógica de pathfinding */ } public class CellValidator { /* Lógica de validação */ } \uD83C\uDFAF Casos de Uso Jogos de Construção de Cidades Posicionamento de edifícios Sistema de ruas e pathfinding Zonas de construção definidas Jogos de Fazenda/Agricultura Plantio em grid organizado Sistema de irrigação Expansão de terrenos Jogos de Estratégia Posicionamento de unidades Construção de bases Sistema de recursos por tile Jogos de Puzzle Posicionamento preciso de peças Validação de movimentos Sistema de snap-to-grid \uD83D\uDE80 Vantagens do Sistema Para Desenvolvedores Produtividade - Sistema pronto para uso imediato Flexibilidade - Módulos intercambiáveis e configuráveis Documentação - API completamente documentada Exemplos - Casos de uso práticos incluídos Performance - Otimizações já implementadas Para Jogadores Responsividade - Feedback visual imediato Intuitividade - Controles naturais e previsíveis Fluidez - Animações suaves e transições Precisão - Sistema de snap automático Visual - Efeitos de hover e preview \uD83D\uDCC8 Próximos Passos Configuração Inicial Setup do Projeto - Configure seu ambiente Configuração Básica - Primeiros passos Exemplos Práticos - Casos de uso reais Exploração Avançada API Reference - Documentação completa Módulos Especializados - Funcionalidades avançadas Customização - Adaptação para suas necessidades \uD83C\uDFA8 Filosofia de Design Simplicidade sem Comprometer Poder O projeto foi desenhado com a filosofia de \"fácil de usar, difícil de quebrar\": Interface Simples - API intuitiva para operações comuns Poder Avançado - Funcionalidades sofisticadas quando necessário Documentação Clara - Cada funcionalidade bem explicada Exemplos Práticos - Código pronto para adaptar Escalabilidade Incorporada Arquitetura Modular - Adicione novos módulos facilmente Performance Otimizada - Suporta grids grandes sem impacto Configuração Flexível - Adapte-se a diferentes necessidades Extensibilidade - Herde classes base para funcionalidades customizadas \uD83C\uDFC1 Conclusão O Tycoon Project não é apenas um sistema de grid - é uma plataforma completa para desenvolvimento de jogos que requerem posicionamento preciso, interface intuitiva e performance otimizada. Com sua arquitetura modular, documentação completa e foco em performance, este projeto oferece uma base sólida para criar experiências de jogo envolventes e profissionais. Pronto para começar? Explore a documentação da API ou siga o guia de configuração para dar seus primeiros passos! Desenvolvido por Murillo Gomes Yonamine Unity 2022.3 LTS | C# 9.0 | Arquitetura Modular"
  },
  "index.html": {
    "href": "index.html",
    "title": "\uD83C\uDFD7️ Tycoon Project | Tycoon Project API",
    "summary": "\uD83C\uDFD7️ Tycoon Project Sistema Modular de Grid para Unity Arquitetura robusta e escalável para jogos do gênero tycoon \uD83C\uDFAF Visão Geral do Projeto O Tycoon Project é um sistema completo de grid desenvolvido em Unity para criação de jogos do gênero tycoon. Implementa uma arquitetura modular robusta com funcionalidades avançadas de posicionamento de tiles, efeitos visuais responsivos e gerenciamento inteligente de recursos. ✨ Características Principais \uD83C\uDFD7️ Arquitetura Modular - Separação clara de responsabilidades \uD83C\uDFAE Sistema de Grid Inteligente - Conversão automática de coordenadas \uD83D\uDDB1️ Efeitos de Hover Responsivos - Feedback visual em tempo real \uD83D\uDD04 Object Pool Otimizado - Performance superior com reutilização de objetos \uD83D\uDED2 Sistema de Loja Intuitivo - Interface animada e responsiva \uD83D\uDCF1 Input System Moderno - Baseado no Unity Input System \uD83D\uDE80 Começar Agora \uD83D\uDCDA Guia de Introdução Aprenda os conceitos básicos e configure seu primeiro projeto. → Começar Tutorial \uD83D\uDD27 Referência da API Documentação completa de todas as classes e métodos. → Explorar API \uD83C\uDFAE Como Começar Guia rápido para configuração e primeiros passos. → Setup Rápido \uD83C\uDFD7️ Arquitetura do Sistema \uD83D\uDCE6 Componentes Principais Sistema Funcionalidade Status Grid System Gerenciamento central e coordenação ✅ Completo Grid Modules Módulos especializados (Hover, Path, etc.) ✅ Completo Tile System Comportamento e pooling de tiles ✅ Completo Shop System Interface de loja e seleção ✅ Completo \uD83C\uDFA8 Funcionalidades Destacadas Sistema de Hover Inteligente // Configuração simples e poderosa GridManager.Instance.SetHoverEnabled(true); GridManager.Instance.SetHoverColor(Color.yellow); Object Pool Otimizado // Reutilização eficiente de objetos GameObject tile = TilePool.Instance.GetPooledObject(); tile.SetActive(true); Posicionamento Intuitivo // Sistema de ghost mode para preview tile.HandleSelection(true); // Ativa modo fantasma // Clique para posicionar automaticamente \uD83C\uDFAE Demonstração Visual Funcionalidades em Ação \uD83D\uDDB1️ Hover Effects - Destaque visual de células disponíveis \uD83D\uDC7B Ghost Mode - Preview transparente durante posicionamento \uD83C\uDFA8 Animações Suaves - Transições coordenadas da loja \uD83D\uDCD0 Grid Responsivo - Conversão automática de coordenadas \uD83D\uDD04 Performance Otimizada - Object pooling para tiles Controles Principais Ação Controle Resultado Abrir Loja Tab Interface animada de seleção Selecionar Tile Clique na Loja Ativa modo de posicionamento Posicionar Clique no Grid Confirma posição do tile Hover Visual Mouse sobre Grid Destaque de células livres \uD83D\uDCCA Tecnologias Utilizadas Unity 6 C# 9.0 Unity Input System ScriptableObjects Object Pooling Modular Architecture \uD83C\uDFC6 Padrões de Design Implementados \uD83C\uDFAF Singleton Pattern - GridManager e TilePool \uD83D\uDD27 Module Pattern - Separação de responsabilidades \uD83D\uDD04 Object Pool Pattern - Otimização de performance \uD83D\uDC40 Observer Pattern - Sistema de eventos de input \uD83D\uDD04 State Pattern - Estados bem definidos de tiles \uD83D\uDCC8 Próximos Passos \uD83D\uDE80 Explore o Projeto Leia a Introdução - Entenda os conceitos fundamentais Configure o Ambiente - Setup inicial rápido Explore a API - Documentação completa dos componentes Experimente o Sistema - Teste as funcionalidades interativas \uD83C\uDF1F Desenvolvido com Unity 6 \uD83C\uDF1F Documentação gerada com DocFX"
  }
}